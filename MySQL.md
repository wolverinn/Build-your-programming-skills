# MySQL
MySQL原理的学习，推荐掘金小册：https://juejin.cn/book/6844733769996304392，看这本就够了

## 服务端处理请求的过程
![mysql server](vx_images/1262423080862.png)

## InnoDB引擎中一条记录是怎样存储的
页是MySQL中磁盘和内存交互的基本单位，也是MySQL管理存储空间的基本单位。一个页一般是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为行溢出。

记录在磁盘上的存放方式称为“行格式”，InnoDB存储引擎到现在为止设计了4种不同类型的行格式，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`行格式。

### Compact 行格式
![compact行格式](vx_images/5561353070863.png)

- **变长字段长度列表**

对于`varchar()`，`text`，或者以变长字符集（比如utf-8）存储的`char()`，等数据类型，存储多少字节的数据是不固定的，因此InnoDB会在记录的开头存储这些变长字段的真实数据占用的字节长度，形成一个变长字段长度列表，在这个列表中各变长字段占用的字节数按照列的顺序**逆序存放**。

变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 。并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

- **NULL值列表**

如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序**逆序排列**。二进制位值为1表示该列的值为NULL。

MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。

- **记录头信息**

由固定5个字节组成，之后讲数据页结构的时候会详细解释字段代表的含义

![记录头信息](vx_images/2802221099289.png)

- **记录的真实数据**

除了我们自己定义的列数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），包括row_id（DB_ROW_ID）、transaction_id（DB_TRX_ID）和roll_pointer（DB_ROLL_PTR）

InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。

### Dynamic和Compressed行格式

这两种行格式类似于COMPACT行格式，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。

## InnoDB数据页的结构
之前说过页是MySQL管理存储空间的基本单位，一个页一般是16KB。MySQL一次会将整个页加载到内存中（原因：内存速度远大于磁盘速度）。现在来看一下InnoDB中存放表中记录和索引的页的结构。了解了索引页的结构可以帮助我们了解后面使用索引查找为什么那么快。

先看数据页的结构，整体如下图：

![数据页结构](vx_images/2052242080869.png)

比较简单的一些字段快速过一下：File Header和Page Header 是一些通用信息，其中用于存放记录的数据页的 File Header 中有FIL_PAGE_PREV和FIL_PAGE_NEXT，用于将多个页连成双向链表，如下图：

![数据页双向链表](vx_images/1021628160869.png)

File Trailer 用于校验页是否完整（为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的LSN值，如果首部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了问题），Infimum + Supremum 是两个虚拟的行记录，代表最小和最大记录。每当插入一条记录时，都会从 Free Space部分申请空间划到 User Records 部分，直到Free Space空间用尽，意味着这个页已经用完了。

现在我们想要看到插入一堆记录之后，这些记录在页中是怎样组织起来的。首先回顾一下上一节说过的一条记录的格式，其中有个记录头信息，这个很关键，记录头信息里有几个值得我们现在关注的字段：

- `heap_no`：这个属性代表当前记录在本页中的位置，其中页的 Infimum + Supremum 这两条虚拟记录始终占有`heap_no`为0和1的两个值，后面插入的用户记录按照大小，`heap_no`依次递增，这里说的记录大小，对于一条完整的记录来说，就是主键的大小。对于一条索引记录来说，就是索引列的大小。
- `record_type`：这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3
- `n_owned`：下面讲页目录的时候会讲，页中的数据会分组，`n_owned`属性表示每组中的最大记录拥有的记录数，也就是该组内有多少条记录
- `next_record`：表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量（回顾一下一条记录的格式，每条记录的真实数据是在记录头信息之后）。因此，这其实是个单向链表。并且，这个链表的顺序并不是按照插入顺序，而是按照`heap_no`类似的记录大小的顺序，Infimum虚拟记录在最开始，Supremum虚拟记录在最后面。删除记录之后这个链表也会发生变化。

直观的看一下这个链表：

![next_record](vx_images/2128723109295.png)

这里插入一个小问题，为啥`next_record`要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？

因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。

我们看到了页中的记录是用链表组织起来的，但这还不够，因为要在一个页中根据主键快速找到一条记录还是很慢，而快速查找的关键就在页的`Page Directory`结构中。`Page Directory`差不多就是为页内存放的记录做了一个目录，方便快速查找。

### Page Directory
刚刚讲记录的`n_owned`属性的时候说过，一个页中的记录会被分为几组（如何分组马上就讲），每组的最大一条记录的`n_owned`属性表示该组有多少条记录。而 Page Directory 中存放的就是每组的最大一条记录的地址偏移量（被称为槽，slot），Page Directory 就是由 slot 组成的。

那么是如何进行分组的呢？对于最小记录 Infimum 所在的分组只能有 1 条记录，最大记录 Supremum 所在的分组拥有的记录条数只能在 1-8 条之间，剩下的分组中记录的条数范围只能在是 4-8 条之间。所以每插入一条记录的时候，都会根据这条记录的大小匹配到该记录应该属于哪个槽，如果这个槽的记录数还没有满8个，那么就加入这个组，如果满了，会拆分成两个组，一个4条记录，一个5条记录，在页目录中新增一个槽。

![page directory](vx_images/4953150097162.png)

那么，在一个页中根据主键快速查找一条记录的过程就是：通过二分法确定该记录所在的槽，再通过`next_record`形成的链表定位到记录

## 索引
如果只有之前讲的数据页，虽然在页内可以实现根据主键快速定位记录，但我们可以看到在有很多页的情况下还是只能遍历。所以我们需要更强大的方式来定位数据。

索引的数据结构是一个B+树，在非叶子节点上的目录项页，页中的每条目录项记录都存储了一个主键值和页号，这个主键值就是页号对应的页中的最小的主键值。在叶子节点上，则存储了完整的用户记录页。

![索引](vx_images/1661859070870.png)

上边介绍的，在叶子节点里存放完整的用户记录的索引，其实就是聚簇索引，也就是根据主键值进行排序的索引，并且在叶子节点存放了完整的用户记录。InnoDB存储引擎会自动的为我们创建聚簇索引。另外，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

而我们还可以为一张表创建其他列的索引，叫做二级索引，特点是排序使用的条件就不是主键，而是指定的列（先按列的值排序，一样的情况下再用主键值排序），非叶子节点上存储的就是列值、主键值和页号，叶子节点上存储的不是完整的用户记录，而是只有列值和对应的主键值。

![二级索引](vx_images/5693121087163.png)

所以为了根据指定列的条件定位到用户记录，需要先根据这个二级索引的B+树定位到主键值，再根据主键值去聚簇索引上找到完整的用户记录，这个过程也叫做**回表**

我们也可以为一张表创建联合索引，本质上也是二级索引。比如我们为两个列c2和c3创建了联合索引(idx_c2_c3)，那么在索引B+树上排序的规则就是先根据c2列的值排序，相同的情况下再根据c3列的值排序。非叶子节点上记录的是c2列和c3列的值以及页号，叶子节点上存储的是c2和c3列的值以及主键值。

简单提一下 MyISAM 的索引方式，MyISAM 的索引和数据是分开存储的，叶子节点中存放的只有主键值和行号，之后根据行号再去快速定位到用户记录，因此 MyISAM 中建立的索引相当于全都是二级索引。

了解了索引的原理之后我们能看出来几件事情：

1. 索引的代价

可以看出，索引虽然好用，但不能想建就建，还是有代价的，一个是空间上的代价，每个二级索引都需要一颗B+树去存储，第二是时间上的代价，创建更新和删除记录的时候索引的B+树也需要同步修改，性能自然也会受到影响。

2. 联合索引的生效条件

最左匹配原则

3. 字符串匹配

如果是为字符串类型的列创建的索引，在指定条件进行查询的时候，只有精确匹配或者前缀匹配的情况下才能使用到索引。因为字符串的大小比较是按照字符顺序逐个往后比较的。比如 `select * from users where name  like 'li%'`可以用到`name`列的索引，但`select * from users where name  like '%li%'`就无法使用`name`列的索引

4. 排序和分组使用索引会更快

Order by 和 Group by 后面的列，如果不使用索引，那么就需要先回表读取到记录之后，再在内存或者磁盘中进行排序或分组（Filesort，文件排序），这样就意味着很慢。

### 回表的代价
什么是回表上面已经说过了。在根据主键id去聚簇索引上查找完整的用户记录时，由于这些主键id很大概率不是相连的，而在聚簇索引中记录是根据主键id值排列的，所以根据这些并不连续的id值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为随机I/O。一般情况下，顺序I/O比随机I/O的性能高很多。

当要回表的记录很多时，会造成大量的随机I/O，严重影响性能。因此，这种情况下，最好使用**覆盖索引**，即需要查询的列只包含索引列，比如我们有一个`idx_name_age`的联合索引，那么最好使用`select name, age from users where ...`，这样就避免了回表。

### 索引的选择
前面说过了建立索引是有代价的，所以我们希望选取正确的索引。

1. 为where , group by , order by 后面的列建立索引。当然where 后面的查询条件不是都要建立索引，而是要找到区分度大的列
2. 索引列的类型尽量小。比如整数类型，有TINYINT、MEDIUMINT、INT、BIGINT这么几种。数据类型越小，查询时比较操作越快，并且占用的空间也小
3. 对于大字符串，可以只为字符串的前缀建立索引。这样可以减少空间占用，提升比较的性能。当然这样的话是在使用order by 排序时就没法使用索引了
4. 不要创建冗余索引。最常见的就是为联合索引的最左边一列单独创建一个索引，根据索引的原理我们可以知道这样是没有必要的
5. 表连接的条件上创建索引（连接的原理，外连接，访问一次驱动表确定列，再根据条件查询并匹配多次被驱动表）

最后，在写查询语句时也需要注意，需要让索引列单独出现在表达式的一侧，比如：

1. `WHERE my_col * 2 < 4`
2. `WHERE my_col < 4/2`

这两个查询语句只有第二个才能用到索引。

## InnoDB的Buffer Pool
虽然InnoDB是基于磁盘的存储引擎，但是磁盘交互的速度还是太慢了，不可能每次都去读取磁盘。因此我们需要有缓存，在MySQL中，Buffer Pool就是一片连续的内存空间，用来缓存页的数据。默认128M，也可以自己设置。

Buffer Pool 的空间主要可以分为两部分，一部分是缓存的页的数据，每个缓存页的大小都是16KB，一部分是控制信息，如图：

![buffer pool](vx_images/4998819080953.png)

当MySQL从磁盘中读取了一个页的时候，这个页就会被放入Buffer Pool中缓存起来。MySQL为Buffer Pool维护了一个**free链表**（链表的基节点是单独申请的内存空间），用于存放空闲的缓存页的控制块的信息。这样当需要将磁盘上的页放入缓存页时，就可以从free链表中找到空闲的缓存页，缓存数据，然后把该缓存页对应的节点从free链表中移除。

那么当需要读取一个页时，MySQL如何知道这个页是否已经在 Buffer Pool中被缓存了呢？定位一个页，用表**空间号+页号**就可以了，因此，可以用一个哈希表来进行定位。

由于现实情况下往往都是多线程环境，对Buffer Pool的一些操作需要加锁，单一的Buffer Pool可能会影响速度，因此在Buffer Pool特别大的时候（至少超过1G），我们可以把它们拆分成若干个小的Buffer Pool，每个Buffer Pool都称为一个实例，它们都是独立的，独立的去申请内存空间、管理各种链表，所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。

### LRU链表
Buffer Pool的大小终究是有限的，如果已经没有空闲的缓存页了，而这时又从磁盘加载了新的页，必然需要将旧的缓存页移除，那么如何决定移除哪些缓存页呢？Buffer Pool的最终目的还是提高**缓存命中率**，因此这里采用的算法就是LRU（选择最近最少使用的缓存页进行移除），LRU的算法就不介绍了。

虽然旧的缓存页的淘汰策略有了，但是如果仅仅使用最简单的LRU，还是会遇到一些问题，比如预读机制导致缓存的页不一定会用到但又淘汰了已经缓存的页；全表扫描时会导致淘汰掉访问频率非常高的页。因此，MySQL的Buffer Pool其实分成了两部分，一部分叫做**young区域**，用于存放热点数据，一部分叫做**old区域**，存储访问频率不是很高的页；两者的比例取决于系统变量`innodb_old_blocks_pct`。

从磁盘中加载的页首先会放到old区域中（放到old区域的头部），如果超过了一定的时间间隔（系统变量`innodb_old_blocks_time`），又再次对这个页进行访问，那么这个页就会被移到young区域的头部（这样能有效避免全表扫描时访问频率不高的页被加入young区域）。

当然，对于这个LRU链表，还有很多优化策略，比如为了不频繁的移动young区域的节点，只有在访问的页面位于young区域的1/4的后边时，才将其移动到young区域头部，从而提升性能。还有一些其他的优化策略就不一一介绍了。

### Flush链表
如果修改了某个缓存页的数据，那么它就和磁盘上的数据不一致了，这样的缓存页叫做dirty page，我们需要在特定的时机将dirty page的改动同步到磁盘上（频繁的立即同步会严重影响性能因为磁盘很慢）。MySQL会通过一个**Flush链表**来维护dirty page的信息，来记录哪些页是需要将来同步到磁盘的。

后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：

- 扫描LRU链表，发现dirty page就刷新到磁盘
- 从flush链表中刷新一部分页面到磁盘

如果后台刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到Buffer Pool时没有可用的缓存页，这时就会尝试看看LRU链表尾部有没有可以直接释放掉的未修改页面，如果没有的话会不得不将LRU链表尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。

## 查询优化
这部分其实就是搞懂对于我们写的SQL语句，MySQL是怎么执行的，比如是会全表扫描，还是走聚簇索引，还是二级索引，等等。为了了解查询优化，首先我们需要来看两部分，在进行单表查询时有哪些方法，以及表连接是什么原理。

### 单表查询
也就是`select * from users where email = "XXX"`这样的语句，对一张表进行查询。有以下几种方式：

1. const：通过主键或者unique键与常数的等值比较来定位一条记录。这种访问方法是非常快的，因为可以直接通过索引B+树唯一确定一条记录（或者找不到记录）。
2. ref：对不是unique的二级索引进行等值比较（包括NULL），可能会定位到多条记录
3. ref_or_null：对某个二级索引，既有进行等值比较的条件，又有对其等于NULL的比较条件，这时会分别找出来id，再一起回表。比如`select * from users where email = "XXX" or email = NULL`
4. range：对聚簇索引或者二级索引进行范围查找，比如`key1 in (?)`，`key1 > ?`这种。
5. index：不需要回表，直接在二级索引的B+树上就能取到所需的信息。比如`select key1, key2 from users where key2 = ?`（假设有联合索引`idx_key1_key2`），这种情况下虽然key2不是索引，但仍然可以只扫描这个联合索引的B+树，成本比全表扫描小的多
6. all：全表扫描

但是我觉得，上面这几种方式没必要记住，因为拿到一个简单的单表查询语句，我们一般情况下自己就能分析出它会怎么被执行。接下来可以看一下更复杂的情况，索引合并（index merge），也就是可以在一次查询中用到多个二级索引。索引合并有三种情况。

1. Intersection

第一种是`Intersection`，也就是求交集，比如`where`条件里用到了两个二级索引的等值匹配的查询条件，并且是用`AND`连接的，那么就可以分别在这两个索引的B+树上找到符合条件的主键值，然后计算这两组主键值的交集，最后进行回表。

比如`select * from users where key1 = ? and key2 = ?`，这个语句就可以分别在key1和key2的索引B+树中过滤出符合条件的记录，然后计算出主键值的交集，再进行回表操作取出完整记录

对于Intersection方法，有两个地方需要注意，第一是，为什么不通过key1过滤出结果集，回表之后再根据key2的条件过滤呢？原因就在于成本，读取二级索引的操作是顺序IO，而回表操作是随机IO，如果根据key1过滤出的结果非常多，这时性能损耗就比较大了。

第二个需要注意的是，MySQL在求主键值的交集时，需要两部分（或者多部分）的主键值都是有序排列的，如果使用某个二级索引过滤出来的主键值不是有序排列的，也就意味着无法使用Intersection的方法（因为还需要先排序，性能降低）。比如说：

`select * from users where key1 = ? and key2 > ?`

这个语句通过key2过滤出来的主键值就不是排好序的，因此不能使用Intersection方法。

再比如如果有联合索引`idx_part1_part2`：

`select * from users where key1 = ? and part1 = ?`

根据part1过滤出来的条件也不是按照主键值排好序的，因为联合索引的叶子节点上，是先按照part1排序，再按照part2排序，最后按照主键值排序。所以这个语句也不能使用Intersection方法。

根据主键值必须是有序排列的原理，我们可以知道如果查询条件中对主键列进行范围匹配，还是可以用到Intersection方法：

`select * from users where key1 = ? and id > ?`

2. Union
和上面情况类似，不过这次是求并集，对应的是`where`查询条件用`OR`连接起来的情况。其他要求和Intersection是类似的。

3. Sort-Union
Union的条件和Intersection一样苛刻，需要根据二级索引过滤出来的主键值是有序的。而Sort-Union就没那么苛刻，即使过滤出来的主键值不是有序的，也可以先对其进行排序，然后再求并集。

当然，只有Sort-Union方法而并没有Sort-Intersection方法。因为Union适用的场景是过滤出来的主键集合较小，因此排序也很快。而Intersection一般用于过滤出来的主键较多，求交集之后能有效减少回表的情况，这时如果加入Sort-Intersection，排序的开销也会很大。

以上就是索引合并的三种方法，当然，上面说的什么过滤出来的主键值有序之类的，只是使用索引合并的必要条件，不是充分条件，具体是否使用索引合并，还是看优化器判断如何执行成本更低。

### 表连接的原理
我们一般使用的都是内连接和外连接，比如：

```sql
select * from users inner join orders on users.id = orders.user_id where orders.pay_type = 2

select * from users left join orders on users.id = orders.user_id where orders.pay_type = 2
```

使用内连接，则只有两个表中都有符合条件的记录时，才会将记录加入到最后的结果集中；外连接分为左外连接和右外连接，左外连接会选择左侧的表为驱动表，这时即使在被驱动表中没有匹配的记录，这条记录也会加入结果集。

在连接的原理中，首先有一个驱动表和被驱动表的概念。对于内连接，MySQL可以根据执行的效率选择任一张表作为驱动表。对于左外连接，则是左侧的表为驱动表。

MySQL会首先根据前面刚介绍过的单表访问方法，确定对驱动表的访问方法，查询出驱动表的结果集。第二步，针对从驱动表中查询出的每一条记录，到被驱动表中去查找匹配的记录。也就是说，在连接的查询中，驱动表只需要访问一次，被驱动表可能需要访问多次。

上面提到的连接执行方式称为嵌套循环连接（Nested-Loop Join），也就是查询被驱动表的结果集类似一个循环，只能根据驱动表查询出的结果集一条一条记录的到被驱动表中进行匹配。当然，如果驱动表查询出的结果集只有几条记录，这样做也没问题，但现实生活中一般都有很多记录，因此这种执行方式需要进行优化。

优化方式就是，不要一次只在被驱动表中匹配一条记录，而是一次匹配一批。所以MySQL的设计者提出了一个`join buffer`的概念，`join buffer`就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个`join buffer`中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和`join buffer`中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价。这种方式称为使用基于块的嵌套循环连接（Block Nested-Loop Join）。

### 子查询的执行方式
这里主要介绍IN子查询的执行方式，比如：

```sql
select * from users where id in (select user_id from orders where pay_type = 2)
```

我们可以感觉得到，这种写法和连接的写法非常像：

```sql
select users.* from users inner join orders on users.id = orders.user_id where orders.pay_type = 2
```

当然，两者的区别就在于，在内连接的情况下，如果对于`users`表中的某个`id`，`orders`表中有多条`user_id`记录，那么`users`表中的这个记录会被多次加入结果集；而在子查询的写法中这个记录本来应该只在结果集中出现一次。

虽然不能直接转换为连接，但是这种转换为连接的想法又非常诱人。试想一下，如果直接执行上面的子查询，我们只能先单独执行子查询的部分，得到结果集，然后再执行外层查询，这样的问题是如果子查询的结果集太大，就会有下面的问题：

- 子查询的临时结果集太大，内存都放不下
- 外层查询IN中包含的参数过多，性能降低

因此，MySQL针对子查询，提出了`semi-join`（半连接）的概念，将s1表和s2表进行半连接的意思就是：对于s1表的某条记录来说，我们只关心在s2表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留s1表的记录（也就是转换为连接的同时，避免了上面提到的多次加入结果集的情况）。将子查询转换为半连接之后就类似于下面的语句（当然是不能真正执行的）：

```sql
select users.* from users semi join orders on users.id = orders.user_id where orders.pay_type = 2
```

就像单表查询一样，半连接的执行也分为一些不同的情况，下面一一来看下，参考[子查询官方文档](https://dev.mysql.com/doc/refman/5.7/en/semijoins.html)：

- Table Pullout（表上拉）

这种情况适用于子查询中的表在连接条件处的列是该表的唯一索引或者主键，这样一来就避免了上面提到的外层查询中的表的某个记录被重复加入结果集的情况。这样查询语句相当于变为`inner join`

- DuplicateWeedout execution strategy （重复值消除）

那对于一般情况下，子查询中的表确实可能有多条记录，导致外层查询中的表的某个记录会被重复加入结果集的时候，MySQL会使用 DuplicateWeedout，也就是为了消除重复，建立一个临时表，用来存放外层查询的主键，这样便可以使用临时表的主键唯一的特性进行去重了。

- LooseScan execution strategy （松散扫描）（略）

Scan a subquery table using an index that enables a single value to be chosen from each subquery's value group.

- Semi-join Materialization execution strategy

先将子查询的结果集进行**物化（Materialization）**，也就是写入一个临时表里，该临时表的列就是子查询的查询结果中的列，并且会被去重；然后再将整个子查询语句转换为连接查询。临时表一般比较小，所以会使用基于内存的`Memory`引擎，如果超过了某个系统变量，则会转为基于磁盘的存储引擎。

- FirstMatch execution strategy （首次匹配）

也就是先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。

在MySQL中，要将子查询转为semi-join，必须满足一定条件，而下面这些情况下都不能转为semi-join：

- 外层查询的where条件中有其他条件与IN子查询用OR进行连接
- 使用`not in`子查询而不是`in`子查询
- 子查询中包含了`union`
- 子查询中有`group by`或者`having`子句

而对于不能使用semi-join的情况，MySQL仍然会进行优化，有两种方法：

- 进行`IN`到`EXIST`转换（略）
- 对于不相关子查询，先进行物化之后再查询。但这时需要注意的是查询方式，比如`SELECT * FROM s1 
    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = 'a')`这个语句，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。
