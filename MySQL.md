# MySQL

## 服务端处理请求的过程
![mysql server](vx_images/1262423080862.png)

## InnoDB引擎中一条记录是怎样存储的
页是MySQL中磁盘和内存交互的基本单位，也是MySQL管理存储空间的基本单位。一个页一般是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为行溢出。

记录在磁盘上的存放方式称为“行格式”，InnoDB存储引擎到现在为止设计了4种不同类型的行格式，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`行格式。

### Compact 行格式
![compact行格式](vx_images/5561353070863.png)

- **变长字段长度列表**

对于`varchar()`，`text`，或者以变长字符集（比如utf-8）存储的`char()`，等数据类型，存储多少字节的数据是不固定的，因此InnoDB会在记录的开头存储这些变长字段的真实数据占用的字节长度，形成一个变长字段长度列表，在这个列表中各变长字段占用的字节数按照列的顺序**逆序存放**。

变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 。并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

- **NULL值列表**

如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序**逆序排列**。二进制位值为1表示该列的值为NULL。

MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。

- **记录头信息**

由固定5个字节组成，之后讲数据页结构的时候会详细解释字段代表的含义

![记录头信息](vx_images/2802221099289.png)

- **记录的真实数据**

除了我们自己定义的列数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），包括row_id（DB_ROW_ID）、transaction_id（DB_TRX_ID）和roll_pointer（DB_ROLL_PTR）

InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。

### Dynamic和Compressed行格式

这两种行格式类似于COMPACT行格式，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。

## InnoDB数据页的结构
之前说过页是MySQL管理存储空间的基本单位，一个页一般是16KB。现在来看一下InnoDB中存放表中记录和索引的页的结构。了解了索引页的结构可以帮助我们了解后面使用索引查找为什么那么快。

先看数据页的结构，整体如下图：

![数据页结构](vx_images/2052242080869.png)

比较简单的一些字段快速过一下：File Header和Page Header 是一些通用信息，其中用于存放记录的数据页的 File Header 中有FIL_PAGE_PREV和FIL_PAGE_NEXT，用于将多个页连成双向链表，如下图：

![数据页双向链表](vx_images/1021628160869.png)

File Trailer 用于校验页是否完整（为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的LSN值，如果首部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了问题），Infimum + Supremum 是两个虚拟的行记录，代表最小和最大记录。每当插入一条记录时，都会从 Free Space部分申请空间划到 User Records 部分，直到Free Space空间用尽，意味着这个页已经用完了。

现在我们想要看到插入一堆记录之后，这些记录在页中是怎样组织起来的。首先回顾一下上一节说过的一条记录的格式，其中有个记录头信息，这个很关键，记录头信息里有几个值得我们现在关注的字段：

- `heap_no`：这个属性代表当前记录在本页中的位置，其中页的 Infimum + Supremum 这两条虚拟记录始终占有`heap_no`为0和1的两个值，后面插入的用户记录按照大小，`heap_no`依次递增，这里说的记录大小，对于一条完整的记录来说，就是主键的大小。对于一条索引记录来说，就是索引列的大小。
- `record_type`：这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3
- `n_owned`：下面讲页目录的时候会讲，页中的数据会分组，`n_owned`属性表示每组中的最大记录拥有的记录数，也就是该组内有多少条记录
- `next_record`：表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量（回顾一下一条记录的格式，每条记录的真实数据是在记录头信息之后）。因此，这其实是个单向链表。并且，这个链表的顺序并不是按照插入顺序，而是按照`heap_no`类似的记录大小的顺序，Infimum虚拟记录在最开始，Supremum虚拟记录在最后面。删除记录之后这个链表也会发生变化。

直观的看一下这个链表：

![next_record](vx_images/2128723109295.png)

这里插入一个小问题，为啥`next_record`要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？

因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。

我们看到了页中的记录是用链表组织起来的，但这还不够，因为要在一个页中根据主键快速找到一条记录还是很慢，而快速查找的关键就在页的`Page Directory`结构中。`Page Directory`差不多就是为页内存放的记录做了一个目录，方便快速查找。

### Page Directory
刚刚讲记录的`n_owned`属性的时候说过，一个页中的记录会被分为几组（如何分组马上就讲），每组的最大一条记录的`n_owned`属性表示该组有多少条记录。而 Page Directory 中存放的就是每组的最大一条记录的地址偏移量（被称为槽，slot），Page Directory 就是由 slot 组成的。

那么是如何进行分组的呢？对于最小记录 Infimum 所在的分组只能有 1 条记录，最大记录 Supremum 所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。所以每插入一条记录的时候，都会根据这条记录的大小匹配到该记录应该属于哪个槽，如果这个槽的记录数还没有满8个，那么就加入这个组，如果满了，会拆分成两个组，一个4条记录，一个5条记录，在页目录中新增一个槽。

![page directory](vx_images/4953150097162.png)

那么，在一个页中根据主键快速查找一条记录的过程就是：通过二分法确定该记录所在的槽，再通过`next_record`形成的链表定位到记录

## 索引
如果只有之前讲的数据页，虽然在页内可以实现根据主键快速定位记录，但我们可以看到在有很多页的情况下还是只能遍历。所以我们需要更强大的方式来定位数据。

索引的数据结构是一个B+树，在非叶子节点上的目录项页，页中的每条目录项记录都存储了一个主键值和页号，这个主键值就是页号对应的页中的最小的主键值。在叶子节点上，则存储了完整的用户记录页。

![索引](vx_images/1661859070870.png)

上边介绍的，在叶子节点里存放完整的用户记录的索引，其实就是聚簇索引，也就是根据主键值进行排序的索引，并且在叶子节点存放了完整的用户记录。InnoDB存储引擎会自动的为我们创建聚簇索引。另外，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

而我们还可以为一张表创建其他列的索引，叫做二级索引，特点是排序使用的条件就不是主键，而是指定的列（先按列的值排序，一样的情况下再用主键值排序），非叶子节点上存储的就是列值、主键值和页号，叶子节点上存储的不是完整的用户记录，而是只有列值和对应的主键值。

![二级索引](vx_images/5693121087163.png)

所以为了根据指定列的条件定位到用户记录，需要先根据这个二级索引的B+树定位到主键值，再根据主键值去聚簇索引上找到完整的用户记录，这个过程也叫做**回表**

我们也可以为一张表创建联合索引，本质上也是二级索引。比如我们为两个列c2和c3创建了联合索引(idx_c2_c3)，那么在索引B+树上排序的规则就是先根据c2列的值排序，相同的情况下再根据c3列的值排序。非叶子节点上记录的是c2列和c3列的值以及页号，叶子节点上存储的是c2和c3列的值以及主键值。

简单提一下 MyISAM 的索引方式，MyISAM 的索引和数据是分开存储的，叶子节点中存放的只有主键值和行号，之后根据行号再去快速定位到用户记录，因此 MyISAM 中建立的索引相当于全都是二级索引。

了解了索引的原理之后我们能看出来几件事情：

1. 索引的代价

可以看出，索引虽然好用，但不能想建就建，还是有代价的，一个是空间上的代价，每个二级索引都需要一颗B+树去存储，第二是时间上的代价，创建更新和删除记录的时候索引的B+树也需要同步修改，性能自然也会受到影响。

2. 联合索引的生效条件

最左匹配原则

3. 字符串匹配

如果是为字符串类型的列创建的索引，在指定条件进行查询的时候，只有精确匹配或者前缀匹配的情况下才能使用到索引。因为字符串的大小比较是按照字符顺序逐个往后比较的。比如 `select * from users where name  like 'li%'`可以用到`name`列的索引，但`select * from users where name  like '%li%'`就无法使用`name`列的索引

4. 排序和分组使用索引会更快

Order by 和 Group by 后面的列，如果不使用索引，那么就需要先回表读取到记录之后，再在内存或者磁盘中进行排序或分组（Filesort，文件排序），这样就意味着很慢。

### 回表的代价
什么是回表上面已经说过了。在根据主键id去聚簇索引上查找完整的用户记录时，由于这些主键id很大概率不是相连的，而在聚簇索引中记录是根据主键id值排列的，所以根据这些并不连续的id值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为随机I/O。一般情况下，顺序I/O比随机I/O的性能高很多。

当要回表的记录很多时，会造成大量的随机I/O，严重影响性能。因此，这种情况下，最好使用**覆盖索引**，即需要查询的列只包含索引列，比如我们有一个`idx_name_age`的联合索引，那么最好使用`select name, age from users where ...`，这样就避免了回表。

### 索引的选择
前面说过了建立索引是有代价的，所以我们希望选取正确的索引。

1. 为where , group by , order by 后面的列建立索引。当然where 后面的查询条件不是都要建立索引，而是要找到区分度大的列
2. 索引列的类型尽量小。比如整数类型，有TINYINT、MEDIUMINT、INT、BIGINT这么几种。数据类型越小，查询时比较操作越快，并且占用的空间也小
3. 对于大字符串，可以只为字符串的前缀建立索引。这样可以减少空间占用，提升比较的性能。当然这样的话是在使用order by 排序时就没法使用索引了
4. 不要创建冗余索引。最常见的就是为联合索引的最左边一列单独创建一个索引，根据索引的原理我们可以知道这样是没有必要的

最后，在写查询语句时也需要注意，需要让索引列单独出现在表达式的一侧，比如：

1. `WHERE my_col * 2 < 4`
2. `WHERE my_col < 4/2`

这两个查询语句只有第二个才能用到索引。